#!/usr/bin/env python3
"""
Compiles Jupyter notebooks from source snippets.
"""
import os
import sys
import nbformat
from nbformat.v4 import new_notebook, new_markdown_cell, new_code_cell


def create_notebook(source_file, output_file):
    """
    Creates a Jupyter notebook from a Python source file.
    Looks for special comment markers to split into cells.
    """
    if not os.path.exists(source_file):
        print(f"Source file {source_file} not found.")
        return False
    
    with open(source_file, 'r') as f:
        content = f.read()
    
    # Split the content by cell markers
    # Format: 
    # # %% [markdown] - For markdown cells
    # # %% - For code cells
    lines = content.split('\n')
    cells = []
    current_cell = []
    cell_type = "code"  # Default cell type
    
    i = 0
    while i < len(lines):
        line = lines[i]
        
        if line.startswith('# %%'):
            # Save the previous cell if it's not empty
            if current_cell:
                cell_content = '\n'.join(current_cell)
                if cell_type == "markdown":
                    cells.append(new_markdown_cell(cell_content))
                else:
                    cells.append(new_code_cell(cell_content))
                current_cell = []
            
            # Determine the new cell type
            if '[markdown]' in line:
                cell_type = "markdown"
            else:
                cell_type = "code"
        else:
            # For markdown cells, remove the leading # if it exists
            if cell_type == "markdown" and line.startswith('# '):
                line = line[2:]
            current_cell.append(line)
        
        i += 1
    
    # Add the last cell if it's not empty
    if current_cell:
        cell_content = '\n'.join(current_cell)
        if cell_type == "markdown":
            cells.append(new_markdown_cell(cell_content))
        else:
            cells.append(new_code_cell(cell_content))
    
    # Create a new notebook with the cells
    nb = new_notebook(cells=cells)
    
    # Write the notebook to the output file
    with open(output_file, 'w') as f:
        nbformat.write(nb, f)
    
    print(f"Created notebook: {output_file}")
    return True


def add_warning_cell(notebook, source_file):
    """Add a warning cell to the notebook indicating it's auto-generated."""
    source_dir = os.path.dirname(source_file)
    warning_text = f"""# ⚠️ Auto-generated Notebook
    
This notebook is automatically compiled from source files in `{source_dir}`.
**Do not edit this file directly** as your changes will be overwritten.

To make changes:
1. Edit the source file `{source_file}` instead
2. Run the compile script to regenerate this notebook

See [COMPILE.md](docs/COMPILE.md) for more information.
"""
    
    warning_cell = new_markdown_cell(warning_text)
    notebook.cells.insert(0, warning_cell)
    return notebook

def prepare_notebook_for_execution(notebook):
    """Prepare notebook for execution by adding metadata to cells."""
    for i, cell in enumerate(notebook.cells):
        if cell.cell_type == 'code':
            # Initialize empty outputs list if not present
            if not hasattr(cell, 'outputs') or cell.outputs is None:
                cell.outputs = []
            
            # Add execution count if not present
            if not hasattr(cell, 'execution_count') or cell.execution_count is None:
                cell.execution_count = None
                
            # Make sure metadata exists
            if not hasattr(cell, 'metadata'):
                cell.metadata = {}
    
    return notebook

def main():
    """
    Main function for the script.
    Usage: python compile_examples.py <example_path> [--execute]
    
    Example paths:
    - 01_matrix_multiplication - compiles all files in the directory
    - 01_matrix_multiplication/01_introduction - compiles a specific file
    """
    import argparse
    parser = argparse.ArgumentParser(description='Compile Python files to Jupyter notebooks')
    parser.add_argument('example_path', help='Path to the example(s) to compile')
    parser.add_argument('--execute', action='store_true', help='Execute the notebook after compilation')
    args = parser.parse_args()
    
    # Get the project root directory
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    # Process the example path
    example_path = args.example_path
    execute = args.execute
    
    # Check if path has a slash, indicating a specific file
    if '/' in example_path:
        # Specific file within a directory
        dir_name, file_name = example_path.split('/')
        source_file = os.path.join(project_root, "src", "examples", dir_name, f"{file_name}.py")
        output_dir = os.path.join(project_root, "examples", dir_name)
        output_file = os.path.join(output_dir, f"{file_name}.ipynb")
        
        # Make sure the output directory exists
        os.makedirs(output_dir, exist_ok=True)
        
        # Process single file
        compile_and_process_file(source_file, output_file, execute)
    else:
        # Process all files in the directory
        src_dir = os.path.join(project_root, "src", "examples", example_path)
        output_dir = os.path.join(project_root, "examples", example_path)
        
        # Make sure the output directory exists
        os.makedirs(output_dir, exist_ok=True)
        
        # Process all Python files
        for source_file in sorted(os.listdir(src_dir)):
            if source_file.endswith('.py'):
                file_name = os.path.splitext(source_file)[0]
                full_source_path = os.path.join(src_dir, source_file)
                full_output_path = os.path.join(output_dir, f"{file_name}.ipynb")
                compile_and_process_file(full_source_path, full_output_path, execute)

def compile_and_process_file(source_file, output_file, execute=False):
    """Compile a single file to notebook and optionally execute it."""
    print(f"Processing {source_file}...")
    
    if not os.path.exists(source_file):
        print(f"Source file {source_file} not found.")
        return False
    
    if not create_notebook(source_file, output_file):
        print(f"Failed to create notebook from {source_file}")
        return False
        
    # Add warning cell and prepare for execution
    with open(output_file, 'r') as f:
        nb = nbformat.read(f, as_version=4)
    
    nb = add_warning_cell(nb, source_file)
    nb = prepare_notebook_for_execution(nb)
    
    # Fix the last cell if it contains __main__ check
    for i, cell in enumerate(nb.cells):
        if cell.cell_type == 'markdown' and '__name__ == "__main__"' in cell.source:
            parts = cell.source.split('if __name__ == "__main__":')
            if len(parts) > 1:
                # Update the markdown cell to exclude the main check
                nb.cells[i].source = parts[0].strip()
                
                # Add a new code cell with the main check
                main_cell = new_code_cell('if __name__ == "__main__":\n    main()')
                nb.cells.append(main_cell)
                print(f"Fixed main check in {output_file}")
    
    # Save the updated notebook
    with open(output_file, 'w') as f:
        nbformat.write(nb, f)
        
    print(f"Added warning cell to {output_file}")
    
    # Execute the notebook if requested
    if execute:
        import subprocess
        print(f"Executing {output_file}...")
        subprocess.run(["jupyter", "nbconvert", "--execute", "--to", "notebook", 
                       "--inplace", output_file])
        print(f"Successfully executed {output_file}")
    
    return True


if __name__ == "__main__":
    main()